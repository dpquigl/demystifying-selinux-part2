Outline:


Part 1: Usage and Userspace Components
Basic SELinux Concepts and Usage (1 Hour)
Justification for stronger access controls.
What is MAC?
How is MAC different from DAC?
What is SELinux?
Enabling SELinux:
Installing/Enabling in Distribution.
enabled vs disabled.
permissive vs enforcing
Getting and Setting status
sestatus
[gs]etenforce
Flask Abstractions 
Object Security Classes
Permissions
access vectors
What are security labels and access control models?
Label Components and their Meanings
Type Enforcement Component
User Component
Role Component
MLS Component
Userspace tools to view/manipulate security labels.
ls -Z
ps -Z
pstree -Z
chcon
restorecon
matchpathcon
netstat -Z
Mini LAB:
ls -Z /
ls -Z /etc
ls -Z /tmp
ps -Z 
pstree -Z
matchpathcon <random paths>
netstat -Z (for port contexts)
Viewing and modifying local configuration data (Not needed for VT course maybe for LISA one)
Review configuration data semanage can modify
Review which parts of the policy store semanage is modifying
Describe how this would be handled for a monolithic policy
Looking through audit logs and deciphering AVC denials.
Detemining where to look for AVC denials.
Decipherin a raw AVC denial
Using ausearch to look at a processed AVC message.
Using auditwhy to determine what went wrong.
 

LAB: Viewing and manipulating security labels and observing their effects.
Show transition to a domain using passwd (open terminal run passwd, open a second terminal and show process).
Use semanage to set some contexts. (Shows they will need to reimplement some of that functionality possibly). (Not needed for VT class)
Set label of a file incorrectly and observe a denial.

Basic Policy Language Constructs (1 Hour)

Flask definition files
security_classes
initial_sids
access_vectors
Type declarations.
Attribute declarations.
Alias declarations.
The four basic types of policy rules. (Allow, Auditallow, Dontaudit, Neverallow)
Type transitions.
User and Role declarations.

booleans and conditional policy
Node and port interface context labeling.
fs_use_xattr statements
fs_use_task and fs_use_trans statements.
genfscon statements

File Context declarations.
Using audit2allow to make a new policy module.
 

Change labs to say seinfo (other info) instead of sesearch (rules)
LAB: Write a simple policy domain with a few rules a role and a user.
Make sure to give them boilerplate for flask definitions
Have them compile strictly with check_policy.




My thought is that the course material should go as much as possible from general information to specific details.  As much of the management stuff as possible should be pushed down so the students don’t get bogged down and lose sight of the concepts.  Here’s some stream-of-consciousness on a possible syllabus.
 
(Introductory material)
 
·         Need for MAC, why DAC isn’t working, etc.
·         High-level Flask stuff (security server, object manager, classes, permissions).
o   Lab: look at the classes/ and perms/ directories of selinuxfs, check out the file class, etc.
o   Lab: do an access_vector computation using the selinuxfs interface, very basic.
·         High-level SElinux stuff (the kernel part, enforcing versus permission mode, the pseudo-filesystem, where the policy lives, how it gets loaded at boot, concept of an AVC message, how to find the AVC’s).
o   Lab: set enforcing mode
o   Lab: look at some AVC’s
o   Lab: use ls –Z, ps –Z, etc.
·         The SELinux policy language without refpolicy, just the basics.
o   Lab: make a simple monolithic policy
o   Lab: use audit2allow to improve the policy
·         The userspace AVC, just to demonstrate the ability to make up new classes and permissions.
o   Lab: add a fake class and some permissions in a simple policy.  This might involve some daemon server we make that uses the userspace AVC to check the permissions.
 
(OK now we start getting into the details of real usage)
 
·         Some introduction to the semanage utility?
·         Do a policy module here?  Or wait until later?  Or maybe we should skip the monolithic policy above and just do it there (with an empty base policy).
o   Lab: make a refpolicy policy module and load it.
·         Files and file context
o   Why files are special (they are persistent)
o   How files get labeled
o   How to use semanage to manage file contexts
·         Users, logins, and roles
o   Only at this point do we acutally explain what the user:role:type fields of the context are for.
o   All the stuff about semanage login, semanage user, newrole, etc.
o   Lab: add a user to the sysadm role and use newrole to get additional permissions
·         Domains
o   Domain transitions, how programs get into a new context
o   Lab: make a program run in a new domain (actually this may need to come earlier, like in the first section)
·         Init domains
o   Getting an init script to put something in the right domain.
o   Lab: make an init script launch something in the proper domain
·         Network controls
o   Port contexts, interface contexts, limitations
o   Lab: make a network service
o   Lab: use semanage to manage the network stuff.
·         Something on file descriptor security and leaked file descriptors?
 
(Now we finally get into the refpolicy stuff)
·         Refpolicy stuff (interfaces, templates, m4, yay)
o   Lab: make a refpolicy module that calls an interface
o   Lab: define some interfaces
·         Details of how modules get compiled into the final policy
 
(MLS stuff)
·         MLS: just additional constraints on a policy
·         MLS constraints file, etc.
o   Lab: make an MLS policy


I would have liked to do comments inline but it seems that the outlook webmail think doesn't like that.

I was assuming that this would be a 3 to 5 day course. When I taught the course at the android workshop I covered two weeks of materials in one day. I figure that 5 days should be more than enough. The platform used would probably be RHEL 5 since that is what is most relevant to the customer. However we should also create a version of the course that uses RHEL6/Fedora that way we can market it to outside customers as well.

High Lebel Flask Stuff comments:

I like the topics you came up with. I do notice that there is a difference in the emphasis between the outlines we come up with (SELinux Team members or former rather) and when people from the outside come up with an outline (Dan Walsh and some other people). We often focus on the concepts which we think are important but Dan and company seem to think just serve to confuse people. Dan introduces those concepts but doesn't put much emphasis on object classes and permissions at first. He abstracts it quite a bit to talking just purely about labels. We would need to figure out what the right time and in what quantity we should introduce the flask stuff as.

High-level SELinux stuff:
I'm not sure what you mean by the kernel part. Do you mean the kernel command line options? I definitly like showing them the selinux=1 stuff and showing them the difference between enforcing/permissive/disabled.

In terms of introducing the pseudo-filesystem I think the best thing to do is to tell them that it has to be there and if it isn't then something is wrong. Whenever I go through the items in it even if its just the enforce file people's eyes glaze over. Maybe make exploring it an optional lab during a break. Most of the files there are transactional anyway so it doesn't help much to show them. The booleans directory in selinuxfs should only be manipulated through set/getsebool. Otherwise you have people echoing to files and not remembering to commit the changes.

Where the policy lives is good to tell them. I wouldn't go into too much detail for how it gets loaded at boot. That is complex and varies depending on the platform. I think showing them the selinux config file under /etc/selinux would be good and relating it to the directory names under the policy directory.

Finding and dissecting AVCs are necessary but I think it might be better to save until later. We need to introduce labels and probably show how to set and explore the labels in a policy. The first question that I get from people is how do I know what types there are. How do I set labels etc.

SELinux policy language:
I definitely want to introduce the basic concepts. I tried to do a simple monolithic policy lab for the android workshop and it turned out to be a monumental pain to accomplish it. There is a surprisingly large amount of stuff that you need to put in the policy to even get it compiling. We can do this but I would recommend having them install the policy on a separate VM or in a vm snapshot. This way they aren't destroying the labeling on their system with this policy. I don't think this is the section to be introducing audit2allow though. I think we need to make a daemon that is fairly complex (I have one started that I use for my talks) and get them to write policy for it. A bit concept in the admin circles right now is called CONOPS (continuity of operations). The idea is that they have software being developed by an inhouse development group and they want to be integrated into the development process to make deployment easier.  I think that scenario would be a better way to introduce audit2allow and that belongs in the refpolicy section.

Userspace AVC:
I would say this is more of an advanced topic and really would belong in a building secure systems kind of second.

The Second part:

 I like all of the suggestions here. However I think we should build everything on the file transfer daemon that I wrote in terms of introducing concepts. We can write a policy module for that and make the module transition into the correct domain when executed as unconfined or when executed via an init script.  For better or worse refpolicy/fedora policy are the real policy people are going to write. I say we introduce them to that early and give the policy writting concepts in context of that. We can show them an allow rule or a type declaration and then show them the use of it in ref policy.

Something we need to add is customization of standard services in non-standard ways. For example moving /var/www to soemwhere else and introducing semanage fcontext -e to handle it.

I'll work on merging our outlines when I get home from work. If you want to cover userspace development using libselinux (which would probably be necessary for userspace AVC stuff) I can put that in as well. We might even be able to have a section where we describe designing and implementing secure systems with SELinux which would incorporate kernel policy along with userspace AVC extensions and userspace object manager policies.

Dave







http://major.io/2011/09/15/receive-e-mail-reports-for-selinux-avc-denials/
http://major.io/2011/09/07/getting-apache-php-and-memcached-working-with-selinux/
http://sheltren.com/stop-disabling-selinux
https://blogs.oracle.com/jsmyth/entry/selinux_and_mysql
http://siddharth.livejournal.com/826.html
http://siddharth.livejournal.com/1170.html
http://drupalwatchdog.com/2/2/apache-selinux
http://www.cyberciti.biz/faq/linux-tar-rsync-preserving-acls-selinux-contexts/
http://linuxfollies.blogspot.com/2013/03/writing-new-selinux-policy-module-for.html



-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

On 07/15/2013 09:07 AM, David Quigley wrote:
> On 07/15/2013 09:03, Stephen Smalley wrote:
>> On 07/14/2013 01:26 AM, Dave Quigley wrote:
>>> Do we have an equivalent of matchpathcon for ports? Where we can
>>> specify a protocol and port and see what the policy thinks it labeled?
>>
>> Closest approximation I can think of would be to use checkpolicy -Mdb
>> /path/to/policy and then choose 9, input the protocol and port number,
>> choose 1, and input the SID that was displayed.
>>
>> It would be very nice to have a more user-friendly (and scriptable) 
>> interface to the checkpolicy -d (debug) functionality.
>
>
> So over on fedora-selinux dominic grift suggested I use sepolicy network
> to check it out. The only issue with its usage is that it doesn't tell you
> what it actually is. Instead it gives you all rules that will match and you
> have to realize the most specific one wins. It is however sufficient for my
> talk so I'll probably use it.
>
> Dave
>
> -- This message was distributed to subscribers of the selinux mailing
> list. If you no longer wish to subscribe, send mail to
> majordomo@tycho.nsa.gov with the words "unsubscribe selinux" without quotes
> as the message.
>
>

sepolicy network -p 80
80: tcp http_port_t 80
80: udp reserved_port_t 1-511
80: tcp reserved_port_t 1-511

sepolicy is reading the info from the running kernel.

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.13 (GNU/Linux)
Comment: Using GnuPG with Thunderbird - http://www.enigmail.net/

iEYEARECAAYFAlHkFAoACgkQrlYvE4MpobPyjACZATRsJA2eCVvP+Sxh2JLNFsMh
UDAAoJsKirzrltnsHyzcqOlD0Ff1ompX
=9wDr
-----END PGP SIGNATURE-----

--
This message was distributed to subscribers of the selinux mailing list.
If you no longer wish to subscribe, send mail to majordomo@tycho.nsa.gov with
the words "unsubscribe selinux" without quotes as the message.




